name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

env:
  GO_VERSION: '1.25'
  POSTGRES_VERSION: '15-alpine'
  DATABASE_HOST: 'localhost'
  DATABASE_PORT: '5432'
  DATABASE_USER: 'melodia_admin'
  DATABASE_PASSWORD: 'melodia_password'
  DATABASE_NAME: 'melodiadb'

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_DB: melodiadb
          POSTGRES_USER: melodia_admin
          POSTGRES_PASSWORD: melodia_password
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}
        cache: true

    - name: Install dependencies
      run: go mod download

    - name: Run linter
      run: |
        # Instalar golangci-lint si no estÃ¡ disponible
        if ! command -v golangci-lint &> /dev/null; then
          curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v1.55.2
        fi
        golangci-lint run ./...

    - name: Run unit tests
      run: go test -v -race -coverprofile=coverage.out ./...

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.out
        flags: unittests
        name: codecov-umbrella
        fail_ci_if_error: false

    - name: Wait for database to be ready
      run: |
        echo "Waiting for PostgreSQL to be ready..."
        timeout 60s bash -c 'until pg_isready -h ${{ env.DATABASE_HOST }} -p ${{ env.DATABASE_PORT }} -U ${{ env.DATABASE_USER }}; do sleep 2; done'

    - name: Run integration tests
      env:
        DATABASE_HOST: ${{ env.DATABASE_HOST }}
        DATABASE_PORT: ${{ env.DATABASE_PORT }}
        DATABASE_USER: ${{ env.DATABASE_USER }}
        DATABASE_PASSWORD: ${{ env.DATABASE_PASSWORD }}
        DATABASE_NAME: ${{ env.DATABASE_NAME }}
      run: |
        # Ejecutar tests de integraciÃ³n
        go test -v -tags=integration ./...

  build:
    name: Build and Test Docker Image
    runs-on: ubuntu-latest
    needs: test
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build Docker image
      run: |
        docker build -t melodia-api:test .
        echo "Docker image built successfully"

    - name: Test Docker image
      run: |
        # Verificar que la imagen se construyÃ³ correctamente
        docker images | grep melodia-api
        docker run --rm melodia-api:test --help || true

  security:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: test
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  deploy-preview:
    name: Deploy Preview
    runs-on: ubuntu-latest
    needs: [test, build, security]
    if: github.event_name == 'pull_request'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Comment PR with test results
      uses: actions/github-script@v7
      with:
        script: |
          const { data: comments } = await github.rest.issues.listComments({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
          });
          
          const botComment = comments.find(comment => 
            comment.user.type === 'Bot' && 
            comment.body.includes('ðŸš€ CI/CD Pipeline Results')
          );
          
          const commentBody = `ðŸš€ **CI/CD Pipeline Results**
          
          âœ… **Tests**: All tests passed successfully
          âœ… **Build**: Docker image built successfully  
          âœ… **Security**: Security scan completed
          
          This PR is ready for review! ðŸŽ‰
          
          _Generated by GitHub Actions_`;
          
          if (botComment) {
            await github.rest.issues.updateComment({
              comment_id: botComment.id,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody,
            });
          } else {
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody,
            });
          }
